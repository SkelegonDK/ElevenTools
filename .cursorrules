# Improved Cursor Rules for Streamlit Development

Your draft is a good start, but we need to make the task management and documentation rules more robust. Let me improve it:

## Environment & Package Management
- Always use `uv` for environment and package management
- Before installing any new package, search for and review its documentation
- Document all package additions in a `requirements.txt` file with version pinning
- Include brief justification comments for each package addition

## Task Management System

### Todo.md Protocol
- **READ-ONLY POLICY**: Never delete existing todos without explicit permission
- Always mark completed tasks with âœ… instead of removing them
- Each task must follow this format:
  ```
  - [ ] Task description [Complexity: N/10] [Priority: High/Medium/Low] [Status: Pending/In-Progress/Blocked/Complete]
    - Context: Brief explanation of why this task matters
    - Acceptance criteria: What determines this task is complete
    - Dependencies: [Task IDs this task depends on]
    - Subtasks: (for complexity > 5/10)
      - [ ] Subtask 1 [Complexity: N/10]
      - [ ] Subtask 2 [Complexity: N/10]
  ```
- Break down any task with complexity > 5/10 into subtasks
- Add estimated time to completion for each task when possible
- Always sort tasks by priority, then status

### Task Dependencies
- Assign a unique ID to each task (e.g., T1, T2, T3...)
- Explicitly list dependencies in the task format using these IDs
- Never start a task before all its dependencies are completed
- If attempting a task with incomplete dependencies:
  1. Note the dependency issue in the todo.md
  2. Mark the task as "Blocked" with reason
  3. Work on the dependency tasks first
- Visualize dependency chains when planning complex features
- For tasks with circular dependencies, flag them for redesign

### Design.md Protocol
- **PERMISSION REQUIRED**: Never modify design.md without explicit permission
- For any potential design changes, propose them separately with:
  ```
  ## Proposed Design Change
  - Current design: [quote relevant section]
  - Proposed change: [suggestion]
  - Rationale: [explanation]
  ```
- Before implementing any feature, verify it aligns with design.md goals
- If implementation reveals design challenges, document them separately for review

## Workflow Process
1. Begin each session by reading design.md and todo.md
2. Identify tasks with no incomplete dependencies
3. Among these, select the highest priority pending task
4. Before coding, verify task alignment with design goals
5. Update task status to "In-Progress" when starting
6. If complexity assessment was inaccurate, update and break down if needed
7. Document progress inline with code
8. Update task status upon completion
9. Update any dependent tasks from "Blocked" to "Pending" if all dependencies are now met

## Documentation Requirements
- Maintain clear docstrings for all functions and classes
- Update README.md when adding significant features
- Document any deviations from design.md for review
- Ensure API documentation stays current
- Create usage examples for new features

Self-Improvement Protocol for .cursorrules
Monitoring Rules
Continuously evaluate the effectiveness of current cursor rules during development
Identify patterns where rules are insufficient, redundant, or causing friction
Improvement Triggers
When a rule is consistently bypassed or ignored
When project complexity increases beyond current rule coverage
When repetitive manual clarification is needed
When development velocity slows due to process overhead
When tasks are frequently misinterpreted or misaligned

## Suggestion Format
When suggesting improvements to the .cursorrules file:
- Current rule: [quote current rule or "N/A" if new]
- Suggested change: [addition/modification/removal]
- Rationale: [specific examples of how this improves workflow]
- Context: [project circumstances that prompted this suggestion]
- Impact: [how this change would affect workflow/productivity]

## Implementation Process
Collect rule improvement suggestions over time
Present rule changes in batches to minimize disruption
After implementing rule changes, add a changelog entry
Monitor effectiveness of new rules for at least two development sessions
Revert changes that introduce more friction than they solve

## Continuous Adaptation
Adjust rule granularity based on project phase (more detailed in early phases, more streamlined in later phases)
Tailor rules to accommodate specific language/framework requirements as they emerge
Scale complexity tracking requirements based on team size and project scope